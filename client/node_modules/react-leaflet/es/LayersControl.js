var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

import { Control } from 'leaflet';
import React, { cloneElement, Component, Children, Fragment } from 'react';

import { LeafletProvider, withLeaflet } from './context';
import MapControl from './MapControl';


// Abtract class for layer container, extended by BaseLayer and Overlay
export var ControlledLayer = function (_Component) {
  _inherits(ControlledLayer, _Component);

  function ControlledLayer() {
    _classCallCheck(this, ControlledLayer);

    return _possibleConstructorReturn(this, _Component.apply(this, arguments));
  }

  ControlledLayer.prototype.componentDidUpdate = function componentDidUpdate(_ref) {
    var checked = _ref.checked;

    if (this.props.leaflet.map == null) {
      return;
    }
    // Handle dynamically (un)checking the layer => adding/removing from the map
    if (this.props.checked === true && (checked == null || checked === false)) {
      this.props.leaflet.map.addLayer(this.layer);
    } else if (checked === true && (this.props.checked == null || this.props.checked === false)) {
      this.props.leaflet.map.removeLayer(this.layer);
    }
  };

  ControlledLayer.prototype.componentWillUnmount = function componentWillUnmount() {
    this.props.removeLayerControl(this.layer);
  };

  ControlledLayer.prototype.addLayer = function addLayer() {
    throw new Error('Must be implemented in extending class');
  };

  ControlledLayer.prototype.removeLayer = function removeLayer(layer) {
    this.props.removeLayer(layer);
  };

  ControlledLayer.prototype.render = function render() {
    var children = this.props.children;

    return children ? React.createElement(
      LeafletProvider,
      { value: this.contextValue },
      children
    ) : null;
  };

  return ControlledLayer;
}(Component);

var BaseLayer = function (_ControlledLayer) {
  _inherits(BaseLayer, _ControlledLayer);

  function BaseLayer(props) {
    _classCallCheck(this, BaseLayer);

    var _this2 = _possibleConstructorReturn(this, _ControlledLayer.call(this, props));

    _this2.addLayer = function (layer) {
      _this2.layer = layer; // Keep layer reference to handle dynamic changes of props
      var _this2$props = _this2.props,
          addBaseLayer = _this2$props.addBaseLayer,
          checked = _this2$props.checked,
          name = _this2$props.name;

      addBaseLayer(layer, name, checked);
    };

    _this2.contextValue = _extends({}, props.leaflet, {
      layerContainer: {
        addLayer: _this2.addLayer.bind(_this2),
        removeLayer: _this2.removeLayer.bind(_this2)
      }
    });
    return _this2;
  }

  return BaseLayer;
}(ControlledLayer);

var Overlay = function (_ControlledLayer2) {
  _inherits(Overlay, _ControlledLayer2);

  function Overlay(props) {
    _classCallCheck(this, Overlay);

    var _this3 = _possibleConstructorReturn(this, _ControlledLayer2.call(this, props));

    _this3.addLayer = function (layer) {
      _this3.layer = layer; // Keep layer reference to handle dynamic changes of props
      var _this3$props = _this3.props,
          addOverlay = _this3$props.addOverlay,
          checked = _this3$props.checked,
          name = _this3$props.name;

      addOverlay(layer, name, checked);
    };

    _this3.contextValue = _extends({}, props.leaflet, {
      layerContainer: {
        addLayer: _this3.addLayer.bind(_this3),
        removeLayer: _this3.removeLayer.bind(_this3)
      }
    });
    return _this3;
  }

  return Overlay;
}(ControlledLayer);

var LayersControl = function (_MapControl) {
  _inherits(LayersControl, _MapControl);

  function LayersControl(props) {
    _classCallCheck(this, LayersControl);

    var _this4 = _possibleConstructorReturn(this, _MapControl.call(this, props));

    _this4.controlProps = {
      addBaseLayer: _this4.addBaseLayer.bind(_this4),
      addOverlay: _this4.addOverlay.bind(_this4),
      leaflet: props.leaflet,
      removeLayer: _this4.removeLayer.bind(_this4),
      removeLayerControl: _this4.removeLayerControl.bind(_this4)
    };
    return _this4;
  }

  LayersControl.prototype.createLeafletElement = function createLeafletElement(props) {
    var _children = props.children,
        options = _objectWithoutProperties(props, ['children']);

    return new Control.Layers(undefined, undefined, options);
  };

  LayersControl.prototype.updateLeafletElement = function updateLeafletElement(fromProps, toProps) {
    _MapControl.prototype.updateLeafletElement.call(this, fromProps, toProps);
    if (toProps.collapsed !== fromProps.collapsed) {
      if (toProps.collapsed === true) {
        this.leafletElement.collapse();
      } else {
        this.leafletElement.expand();
      }
    }
  };

  LayersControl.prototype.componentWillUnmount = function componentWillUnmount() {
    var _this5 = this;

    setTimeout(function () {
      _MapControl.prototype.componentWillUnmount.call(_this5);
    }, 0);
  };

  LayersControl.prototype.addBaseLayer = function addBaseLayer(layer, name) {
    var checked = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    if (checked && this.props.leaflet.map != null) {
      this.props.leaflet.map.addLayer(layer);
    }
    this.leafletElement.addBaseLayer(layer, name);
  };

  LayersControl.prototype.addOverlay = function addOverlay(layer, name) {
    var checked = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    if (checked && this.props.leaflet.map != null) {
      this.props.leaflet.map.addLayer(layer);
    }
    this.leafletElement.addOverlay(layer, name);
  };

  LayersControl.prototype.removeLayer = function removeLayer(layer) {
    if (this.props.leaflet.map != null) {
      this.props.leaflet.map.removeLayer(layer);
    }
  };

  LayersControl.prototype.removeLayerControl = function removeLayerControl(layer) {
    this.leafletElement.removeLayer(layer);
  };

  LayersControl.prototype.render = function render() {
    var _this6 = this;

    var children = Children.map(this.props.children, function (child) {
      return child ? cloneElement(child, _this6.controlProps) : null;
    });
    return React.createElement(
      Fragment,
      null,
      children
    );
  };

  return LayersControl;
}(MapControl);

LayersControl.BaseLayer = BaseLayer;
LayersControl.Overlay = Overlay;


export default withLeaflet(LayersControl);